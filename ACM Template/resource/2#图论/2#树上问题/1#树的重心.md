## 实现

对于树上的每一个点，计算其所有子树中最大的子树节点数，这个值最小的点就是这棵树的重心。

```cpp
void dfs(cint loc, cint fa) {
    int pre = 0;
    son[loc] = 1;
    for(int v: to[loc]) {
        if(v != fa) {
            dfs(v, loc);
            pre = max(pre, son[v]);
            son[loc] += son[v];
        }
    }
    pre = max(pre, n-son[loc]);
    if(pre < st) {
        st = pre; # 最大儿子的最小值
        ans = loc; # 最大儿子的编号
    }
}
```



## 性质

1. 一棵树最多有两个重心，且相邻
2. 以树的重心为根时，所有子树的大小都不超过整棵树大小的一半
3. 在一棵树上添加或删除一个叶子，那么它的重心最多只移动一条边的距离
4. 把两棵树通过一条边相连得到一棵新的树，那么新的树的重心在连接原来两棵树的重心的路径上
5. 树中所有点到某个点的距离和中，到重心的距离和是最小的；如果有两个重心，那么到它们的距离和一样

## 一点证明

首先证明如果树有两个重心，则它们必相邻

设两点分别为 a ， b ，且它们之间的简单路径经过的点的个数不为 0 ，即它们不相邻

不妨认为 a 在树中的深度大于 b

那么，点 a 向上的子树大小一定**大于**点 b 向上的子树，同时**大于**点 b 向下不经过点 a 的子树

同理，点 b 向下经过点 a 的子树一定**大于**点 a 向下的子树

所以，最大值仅由这两棵子树决定，而只要两点不相邻，上述总是成立的

不难发现，这两种子树，在 a 或 b 沿着两点间简单路径移动时会减小，不符合重心的定义

再证最多只有两个重心

显然，如果树的重心大于两个，至少有一对重心无法相邻	